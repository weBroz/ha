<!--
Cartoon Camera + NASA Pollution Overlay (Smoke Effect)
Single-file HTML (includes CSS + JS)

What this does:
- Opens the user's camera and paints a processed (cartoon-ish) version to a <canvas>.
- Uses geolocation to get lat/lon and fetches pollution data from NASA POWER API (Aerosol Optical Depth).
- Adds a smoke effect overlay on the video, where smoke density increases with pollution intensity (AOD â†’ AQI mapping).

Important deployment notes:
- Must be served over HTTPS or localhost for camera & geolocation.
- NASA POWER API does not require an API key.
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cartoon Camera + NASA Pollution Smoke</title>
  <style>
    body{margin:0;background:#000;display:flex;justify-content:center;align-items:center;height:100vh;color:#fff;font-family:sans-serif}
    #outputCanvas{width:100%;height:100%;object-fit:cover}
    #info{position:absolute;top:10px;left:10px;background:rgba(0,0,0,0.5);padding:10px;border-radius:8px;font-size:14px}
    #smokeCanvas{position:absolute;top:0;left:0;pointer-events:none}
  </style>
</head>
<body>
  <video id="video" playsinline autoplay muted style="display:none"></video>
  <canvas id="outputCanvas" width="1280" height="720"></canvas>
  <canvas id="smokeCanvas" width="1280" height="720"></canvas>
  <div id="info">Loading...</div>

<script>
const video = document.getElementById('video');
const canvas = document.getElementById('outputCanvas');
const ctx = canvas.getContext('2d');
const smokeCanvas = document.getElementById('smokeCanvas');
const smokeCtx = smokeCanvas.getContext('2d');
const info = document.getElementById('info');

let stream=null;
let running=true;
let lastAQI=0;

// ====== Camera ======
async function startCamera(){
  try{
    stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment',width:{ideal:1280},height:{ideal:720}}});
    video.srcObject = stream;
    await video.play();
    drawLoop();
  }catch(e){alert('Camera error: '+e.message);}
}

// ====== NASA Pollution Fetch ======
async function fetchPollution(lat, lon){
  try {
    const today = new Date().toISOString().slice(0,10).replace(/-/g,'');
    const url = `https://power.larc.nasa.gov/api/temporal/hourly/point?parameters=AOD&community=RE&longitude=${lon}&latitude=${lat}&format=JSON&start=${today}&end=${today}`;
    const res = await fetch(url);
    const data = await res.json();

    if (data.properties && data.properties.parameter && data.properties.parameter.AOD) {
      const values = Object.values(data.properties.parameter.AOD);
      const lastVal = values[values.length - 1]; 
      const aqi = Math.min(500, Math.round(lastVal * 500));
      return { pollutant:'AOD', value:lastVal, aqi };
    }
  } catch (e) {
    console.warn('NASA fetch failed', e);
  }
  return { pollutant:'AOD', value:null, aqi:0 };
}

async function updateLocationAndPoll(){
  if(!navigator.geolocation){alert('Geolocation not available');return;}
  navigator.geolocation.getCurrentPosition(async pos=>{
    const lat=pos.coords.latitude, lon=pos.coords.longitude;
    const data = await fetchPollution(lat, lon);
    lastAQI = data.aqi;
    info.textContent = `Lat:${lat.toFixed(2)}, Lon:${lon.toFixed(2)} | AOD:${data.value} | AQI~${data.aqi}`;
  },err=>{console.warn('geo err',err);});
}

// ====== Cartoon Effect ======
function cartoonize(){
  const w=canvas.width,h=canvas.height;
  ctx.drawImage(video,0,0,w,h);
  let img=ctx.getImageData(0,0,w,h);
  const data=img.data;
  for(let i=0;i<data.length;i+=4){
    data[i]=Math.floor(data[i]/32)*32;
    data[i+1]=Math.floor(data[i+1]/32)*32;
    data[i+2]=Math.floor(data[i+2]/32)*32;
  }
  ctx.putImageData(img,0,0);
}

// ====== Smoke Effect ======
let particles=[];
function createParticles(amount){
  for(let i=0;i<amount;i++){
    particles.push({x:Math.random()*smokeCanvas.width,y:smokeCanvas.height+Math.random()*100,alpha:Math.random(),size:20+Math.random()*40,speed:0.5+Math.random()});
  }
}

function drawSmoke(){
  smokeCtx.clearRect(0,0,smokeCanvas.width,smokeCanvas.height);
  for(let p of particles){
    smokeCtx.fillStyle=`rgba(200,200,200,${p.alpha})`;
    smokeCtx.beginPath();
    smokeCtx.arc(p.x,p.y,p.size,0,Math.PI*2);
    smokeCtx.fill();
    p.y-=p.speed;
    p.alpha-=0.002;
    if(p.alpha<=0){
      p.x=Math.random()*smokeCanvas.width;
      p.y=smokeCanvas.height+50;
      p.alpha=0.5+Math.random()*0.5;
      p.size=20+Math.random()*40;
      p.speed=0.5+Math.random();
    }
  }
}

// ====== Draw Loop ======
function drawLoop(){
  if(!running) return;
  cartoonize();
  // smoke intensity depends on AQI
  let intensity = Math.floor(lastAQI/50); // more AQI = more particles
  createParticles(intensity);
  drawSmoke();
  requestAnimationFrame(drawLoop);
}

// ====== Init ======
(async function init(){
  await startCamera();
  await updateLocationAndPoll();
  setInterval(updateLocationAndPoll,300000); // refresh every 5 minutes
})();

</script>
</body>
</html>
